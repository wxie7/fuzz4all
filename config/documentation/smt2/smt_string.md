(theory Strings
;-------
; Sorts
;-------

 :sorts ((String 0) ; string sort
         (RegLan 0) ; regular expression sort
         (Int 0)    ; integer sort
        )

 :notes
 "There was consensus in the community that having a character type is not
  really necessary and in fact complicates the theory. So the only way to
  express characters is to use strings of length 1.
 "

; In string fields below (which are double-quote-delimited) we cannot write 
; something like "abc" to denote a string constant, we must use ""abc"" instead.

 :notes
 "Because of SMT-LIB's own escaping conventions, string literals are written 
  in quadruple quotes, as in ""abc"", in textual fields here.
 " 

;-----------
; Constants
;-----------

; string constants for _singleton_ strings, 
; i.e., strings consisting of exactly one character 
 :funs_description 
 "All indexed identifiers, all of sort String, of the form 

    (_ char ⟨H⟩) 
   
  where ⟨H⟩ is an SMT-LIB hexadecimal generated by the following BNF grammar

      ⟨H⟩ ::= #x⟨F⟩ | #x⟨F⟩⟨F⟩ | #x⟨F⟩⟨F⟩⟨F⟩ | #x⟨F⟩⟨F⟩⟨F⟩⟨F⟩ | #x⟨2⟩⟨F⟩⟨F⟩⟨F⟩⟨F⟩
      ⟨2⟩ ::= 0 | 1 | 2 
      ⟨F⟩ ::= ⟨2⟩ | 3 | 4 | 5 | 6 | 7 | 8 | 9
            | a | b | b | d | e | f
            | A | B | C | D | E | F 

   Ex:  (_ char #xA)  (_ char #x4E)  (_ char #x123)  (_ char #x1BC3D)  
  
   Each identifier (_ char n) denotes a string of length 1 whose only character 
   is the Unicode character with code point n. We identify Unicode characters
   with their code point, expressed as a hexadecimal.
   For instance, 
   - (_ char #x2B) denotes the string ""+"" whose only character has code point 
     0x0002B (PLUS SIGN); 
   - (_ char #x27E8) denotes the string ""⟨"" whose only character has code point 
     0x027E8 (MATHEMATICAL LEFT ANGLE BRACKET).
 "

 :notes
 "The use of hexadecimal as indices of indexed symbols requires a (minor)
  extension of the SMT-LIB 2 standard which currently allows only numerals and
  symbols as indices.
 "

 :notes
 "Because of leading zeros, the same one-character string is denoted by more 
  than one constant. 
  Example: (_ char #x2B), (_ char #x02B), (_ char #x002B) and (_ char #x0002B).
 "

 :notes 
 "Rationale for the chosen notation for singleton string constants:
  Because of their large range, Unicode code points are typically given in
  hexadecimal notation. Using a hexadecimal directly to denote the
  corresponding character, however, would create an overloading problem in
  logics that combine this theory with that of bitvectors since hexadecimals
  denote bitvectors there.
  Using them as indices instead avoids this problem.
 "

; String literals (string constants)
 :funs_description 
 "All double-quote-delimited string literals consisting of printable US ASCII 
  characters, i.e., those with Unicode code point from 0x00020 to 0x0007E.
  We refer to these literals as _string constants_.
 "

 :notes
 "The restriction to printable US ASCII characters in string constants is for 
  simplicity since that set is universally supported. Arbitrary Unicode characters 
  can be represented with _escape sequences_ which can have one of the following 
  forms 
      \ud₃d₂d₁d₀  
      \u{d₀} 
      \u{d₁d₀}
      \u{d₂d₁d₀}
      \u{d₃d₂d₁d₀}
      \u{d₄d₃d₂d₁d₀}
  where each dᵢ is a hexadecimal digit and d₄ is restricted to the range 0-2.
  These are the **only escape sequences** in this theory. See later.
  In a later version, the restrictions above on the digits may be extended 
  to allow characters from all 17 Unicode planes.
 "

 :notes
 "SMT-LIB 2.6 has one escape sequence of its own for string literals. Two
  double quotes ("") are used to represent the double-quote character within 
  a string literal such as the one containing this very note. That escape 
  sequence is at the level of the SMT-LIB frontend of a solver, not at the 
  level of this theory. 
 "

 :values 
 "The set of values for String is the set of all string literals; 
  for RegLan it is the set of all ground terms of that sort.
 "

 :notes
 "The set of values for String and RegLan could be restricted further, to 
  remove some redundancies. For instance, we could disallow leading zeros 
  in escape sequences.
  For RegLan, we could insist on some level of normalization for regular
  expression values. These restrictions are left to future versions.
 "

 :notes
 "All function symbols in this theory denote *total* functions, i.e., 
  they are fully specified by the theory. This is achieved by returning 
  _error_ values for inputs where the intended functions are undefined.
  Error outputs are always outside of the range of the intended function,
  so there is no confusion with non-error outputs.
 "

;----------------
; Core functions
;----------------

 ; String functions
 :funs (
        ; String concatenation
        (str.++ String String String :left-assoc)

        ; String length
        (str.len String Int)

        ; Lexicographic ordering
        (str.< String String Bool :chainable)   
       ) 

 ; Regular expression functions
 :funs (
        ; String to RE injection
        (str.to_re String RegLan) 

        ; RE membership
        (str.in_re String RegLan Bool) 

        ; Constant denoting the empty set of strings
        (re.none RegLan)

        ; Constant denoting the set of all strings 
        (re.all RegLan)

        ; Constant denoting the set of all strings of length 1
        (re.allchar RegLan)

        ; RE concatenation
        (re.++ RegLan RegLan RegLan :left-assoc)

        ; RE union
        (re.union RegLan RegLan RegLan :left-assoc)

        ; RE intersection
        (re.inter RegLan RegLan RegLan :left-assoc)

        ; Kleene Closure
        (re.* RegLan RegLan) 
       )

 :note 
 "Function str.to_re allows one to write _symbolic regular expressions_, 
  e.g., RegLan terms with subterms like (str.to_re x) where x is a variable. 
  Such terms have more expressive power than regular expressions. This is 
  intentional, for future developments.
  The restriction to actual regular expressions will be imposed in a logic
  where str.to_re will be applicable to string constants only.
 "
)